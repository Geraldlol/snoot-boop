/**
 * economy.js - Multi-Currency Economy System
 * "Wealth without wisdom is poverty." - Ancient Sect Proverb
 *
 * Implements 9 currencies with meaningful choices:
 * 1. Boop Points (BP) - Active currency, primary progression
 * 2. Purr Power (PP) - Passive generation, technique upgrades
 * 3. Qi - Cultivation energy with realm-based caps
 * 4. Jade Catnip - Rare premium currency
 * 5. Spirit Stones - Dungeon rewards for equipment
 * 6. Heavenly Seals - Prestige currency (Ascension)
 * 7. Sect Reputation - Social/achievements currency
 * 8. Waifu Tokens - Bond activity rewards
 * 9. Goose Feathers - Joke shop with actually good items
 */

console.log('Loading Economy System...');

// ===================================
// CURRENCY DEFINITIONS
// ===================================

const CURRENCIES = {
  bp: {
    id: 'bp',
    name: 'Boop Points',
    shortName: 'BP',
    icon: 'üëÜ',
    emoji: 'üëÜ',
    description: 'The fundamental energy generated by booping snoots.',
    source: 'Active booping, expeditions, events',
    primarySink: 'Cat recruitment, basic upgrades, building costs',
    interestingChoice: 'Spend now on upgrades vs. save for expensive cats',
    color: '#E94560',
    startingAmount: 0,
    canGoNegative: false,
    showInHeader: true,
    displayPriority: 1
  },

  pp: {
    id: 'pp',
    name: 'Purr Power',
    shortName: 'PP',
    icon: 'üò∫',
    emoji: 'üò∫',
    description: 'Passive energy generated by happy cats.',
    source: 'Passive cat generation (AFK)',
    primarySink: 'Technique upgrades, advanced buildings',
    interestingChoice: 'Invest in PP generation infrastructure vs. spend PP now',
    color: '#FFD700',
    startingAmount: 0,
    canGoNegative: false,
    showInHeader: true,
    displayPriority: 2
  },

  qi: {
    id: 'qi',
    name: 'Qi',
    shortName: 'Qi',
    icon: '‚ú®',
    emoji: '‚ú®',
    description: 'Spiritual energy used for cultivation breakthroughs.',
    source: 'Cultivation activities, meditation, booping',
    primarySink: 'Realm breakthroughs, special abilities, tribulations',
    interestingChoice: 'Use for immediate power vs. save for realm breakthrough',
    color: '#00BFFF',
    startingAmount: 0,
    canGoNegative: false,
    showInHeader: false,
    displayPriority: 3,
    hasCap: true,
    baseCap: 100,
    // Cap increases with cultivation realm
    getCapForRealm: (realmId) => {
      const realmCaps = {
        mortal: 100,
        qiCondensation: 200,
        foundationEstablishment: 500,
        coreFormation: 1000,
        nascentSoul: 2500,
        spiritSevering: 5000,
        daoSeeking: 10000,
        immortalAscension: 25000,
        trueImmortal: 100000,
        heavenlySovereign: Infinity
      };
      return realmCaps[realmId] || 100;
    }
  },

  jadeCatnip: {
    id: 'jadeCatnip',
    name: 'Jade Catnip',
    shortName: 'JC',
    icon: 'üíé',
    emoji: 'üíé',
    description: 'Rare crystallized catnip infused with celestial energy.',
    source: 'Rare drops, events, achievements, tribulation rewards',
    primarySink: 'High-tier cat recruitment, premium waifu gifts, special unlocks',
    interestingChoice: 'Which rare cat or premium item to pursue',
    color: '#50C878',
    startingAmount: 0,
    canGoNegative: false,
    showInHeader: false,
    displayPriority: 4,
    premium: true
  },

  spiritStones: {
    id: 'spiritStones',
    name: 'Spirit Stones',
    shortName: 'SS',
    icon: 'üí†',
    emoji: 'üí†',
    description: 'Condensed spiritual energy found in dungeons.',
    source: 'Pagoda runs, dungeon rewards, PvP tournaments',
    primarySink: 'Equipment enhancement, socketing, gear crafting',
    interestingChoice: 'Socket gear for immediate stats vs. save for rare crafts',
    color: '#9370DB',
    startingAmount: 0,
    canGoNegative: false,
    showInHeader: false,
    displayPriority: 5,
    dungeonOnly: true
  },

  heavenlySeals: {
    id: 'heavenlySeals',
    name: 'Heavenly Seals',
    shortName: 'HS',
    icon: 'üîÆ',
    emoji: 'üîÆ',
    description: 'Divine marks earned through Ascension. Permanent power.',
    source: 'Prestige/Ascension only',
    primarySink: 'Permanent upgrades that persist through rebirth',
    interestingChoice: 'Which permanent bonus to prioritize',
    color: '#FFFFFF',
    startingAmount: 0,
    canGoNegative: false,
    showInHeader: false,
    displayPriority: 6,
    prestige: true,
    persistsOnReset: true
  },

  sectReputation: {
    id: 'sectReputation',
    name: 'Sect Reputation',
    shortName: 'Rep',
    icon: 'üèÜ',
    emoji: 'üèÜ',
    description: 'Your standing among the Seven Masters and the Jianghu.',
    source: 'Social features, events, achievements, helping others',
    primarySink: 'Cosmetics, titles, exclusive decorations',
    interestingChoice: 'Flex items vs. functional cosmetic unlocks',
    color: '#FFD700',
    startingAmount: 0,
    canGoNegative: false,
    showInHeader: false,
    displayPriority: 7,
    social: true
  },

  waifuTokens: {
    id: 'waifuTokens',
    name: 'Waifu Tokens',
    shortName: 'WT',
    icon: 'üíï',
    emoji: 'üíï',
    description: 'Tokens of affection earned through bonding activities.',
    source: 'Bond activities with waifus, daily gifts',
    primarySink: 'Premium gifts, special interactions, date events',
    interestingChoice: 'Which waifu to invest in most',
    color: '#FFB6C1',
    startingAmount: 0,
    canGoNegative: false,
    showInHeader: false,
    displayPriority: 8,
    waifuOnly: true
  },

  gooseFeathers: {
    id: 'gooseFeathers',
    name: 'Goose Feathers',
    shortName: 'GF',
    icon: 'ü™∂',
    emoji: 'ü™∂',
    description: 'Trophies from defeated geese. HONK.',
    source: 'Goose defeats only - each goose drops 1 feather',
    primarySink: 'Goose Feather Shop - joke items with actual power',
    interestingChoice: 'Humorous purchases that are surprisingly effective',
    color: '#F5F5F5',
    startingAmount: 0,
    canGoNegative: false,
    showInHeader: false,
    displayPriority: 9,
    gooseOnly: true,
    special: true
  }
};

// ===================================
// CURRENCY CONVERSIONS
// ===================================

const CURRENCY_CONVERSIONS = {
  bp_to_pp: {
    id: 'bp_to_pp',
    from: 'bp',
    to: 'pp',
    rate: 1000, // 1000 BP = 1 PP
    name: 'Purr Meditation',
    description: 'Convert excess BP into PP through focused meditation.',
    minAmount: 1000,
    unlockCondition: { cultivationRealm: 'qiCondensation' },
    cooldown: 0 // No cooldown
  },

  jc_to_bp: {
    id: 'jc_to_bp',
    from: 'jadeCatnip',
    to: 'bp',
    rate: 10000, // 1 JC = 10000 BP
    name: 'Catnip Trade',
    description: 'Trade precious Jade Catnip for a large sum of BP.',
    minAmount: 1,
    unlockCondition: null, // Always available
    cooldown: 0
  },

  gf_to_jc: {
    id: 'gf_to_jc',
    from: 'gooseFeathers',
    to: 'jadeCatnip',
    rate: 100, // 100 GF = 1 JC
    name: 'Feather Alchemy',
    description: 'An ancient goose ritual that transmutes feathers into jade.',
    minAmount: 100,
    unlockCondition: { cobraChickenDefeated: true },
    cooldown: 0
  },

  rep_to_wt: {
    id: 'rep_to_wt',
    from: 'sectReputation',
    to: 'waifuTokens',
    rate: 50, // 50 Rep = 1 WT
    name: 'Fame Gift',
    description: 'Your reputation attracts admirers who bring gifts.',
    minAmount: 50,
    unlockCondition: { waifuUnlocked: true },
    cooldown: 3600000 // 1 hour
  },

  ss_to_bp: {
    id: 'ss_to_bp',
    from: 'spiritStones',
    to: 'bp',
    rate: 5000, // 1 SS = 5000 BP
    name: 'Spirit Liquidation',
    description: 'Dissolve Spirit Stones back into raw energy.',
    minAmount: 1,
    unlockCondition: { pagodaFloor: 10 },
    cooldown: 0
  }
};

// ===================================
// GOOSE FEATHER SHOP
// ===================================

const GOOSE_FEATHER_SHOP = {
  name: 'The Honking Emporium',
  description: 'A mysterious shop that only accepts goose feathers. The items seem absurd, but cultivators whisper of their hidden power...',
  keeper: {
    name: 'Merchant Honksworth',
    emoji: 'ü¶¢',
    dialogue: {
      greeting: [
        "HONK! Welcome to my humble establishment!",
        "*adjusts monocle made of feathers* Ah, a discerning customer!",
        "The finest goods in all the Jianghu... if you appreciate the finer things."
      ],
      purchase: [
        "HONK! A wise investment!",
        "*nods approvingly* You understand quality.",
        "May this item serve you well... HONK!"
      ],
      cantAfford: [
        "HONK! Return when you've defeated more of my brethren!",
        "*shakes head sadly* Not enough feathers...",
        "The geese demand a higher tribute."
      ],
      browse: [
        "Take your time... the geese are patient.",
        "Each feather tells a story of HONK.",
        "These items chose to be here. Just as you chose to HONK."
      ]
    }
  },
  items: {
    // Tier 1: Joke items that are actually decent (5-25 feathers)
    rubber_duck: {
      id: 'rubber_duck',
      name: 'Tactical Rubber Duck',
      emoji: 'ü¶Ü',
      description: 'A yellow rubber duck. It squeaks ominously. Geese fear it.',
      cost: 5,
      category: 'equipment',
      effect: {
        type: 'permanent',
        gooseDodgeReduction: 0.1, // -10% goose dodge chance
        description: 'Geese are 10% easier to hit'
      },
      lore: "The ancient enemy of all geese. They know.",
      oneTime: true
    },

    honk_horn: {
      id: 'honk_horn',
      name: 'Horn of Honking',
      emoji: 'üìØ',
      description: 'A brass horn that produces a powerful HONK. Cats hate it. So do geese.',
      cost: 10,
      category: 'consumable',
      effect: {
        type: 'active',
        uses: 3,
        action: 'force_goose_spawn',
        description: 'Use to immediately spawn a random goose'
      },
      lore: "Blow this and pray you're ready for what comes."
    },

    bread_crumbs: {
      id: 'bread_crumbs',
      name: 'Suspicious Bread Crumbs',
      emoji: 'üçû',
      description: 'Leftover crumbs from the goose dimension. They vibrate slightly.',
      cost: 15,
      category: 'buff',
      effect: {
        type: 'temporary',
        duration: 1800000, // 30 minutes
        gooseRewardBonus: 1.5, // +50% goose rewards
        description: '+50% goose rewards for 30 minutes'
      },
      lore: "The geese cannot resist... and neither can their loot tables."
    },

    peace_treaty: {
      id: 'peace_treaty',
      name: 'Peace Treaty (Fake)',
      emoji: 'üìú',
      description: 'A poorly forged peace treaty. Geese will pretend to believe it.',
      cost: 25,
      category: 'equipment',
      effect: {
        type: 'permanent',
        gooseTimerBonus: 5000, // +5 seconds to catch geese
        description: '+5 seconds to boop geese'
      },
      lore: "Signed by 'Totally Not A Cat'. The geese are skeptical but polite.",
      oneTime: true
    },

    // Tier 2: Actually powerful items (50-100 feathers)
    golden_beak: {
      id: 'golden_beak',
      name: 'Golden Beak Medallion',
      emoji: 'ü•á',
      description: 'A medallion shaped like a golden goose beak. Intimidating.',
      cost: 50,
      category: 'equipment',
      effect: {
        type: 'permanent',
        goldenGooseChance: 0.02, // +2% golden goose spawn rate
        description: '+2% chance for Golden Goose to spawn'
      },
      lore: "The golden geese respect those who display this symbol.",
      oneTime: true
    },

    chaos_egg: {
      id: 'chaos_egg',
      name: 'Egg of Chaos',
      emoji: 'ü•ö',
      description: 'An egg that radiates chaotic energy. It vibrates with potential.',
      cost: 75,
      category: 'consumable',
      effect: {
        type: 'active',
        uses: 1,
        action: 'random_reward',
        possibilities: [
          { chance: 0.4, reward: { bp: 100000 }, desc: '100K BP' },
          { chance: 0.25, reward: { jadeCatnip: 10 }, desc: '10 Jade Catnip' },
          { chance: 0.2, reward: { gooseFeathers: 50 }, desc: '50 Goose Feathers' },
          { chance: 0.1, reward: { cat: 'random_rare' }, desc: 'Rare Cat' },
          { chance: 0.05, reward: { cat: 'goose_cat' }, desc: 'Goose Cat (Legendary!)' }
        ],
        description: 'Hatch for a random reward (mostly good!)'
      },
      lore: "What came first, the chaos or the chicken?"
    },

    feather_cloak: {
      id: 'feather_cloak',
      name: 'Cloak of Many Feathers',
      emoji: 'üß•',
      description: 'A cloak made entirely of goose feathers. Surprisingly comfortable.',
      cost: 100,
      category: 'equipment',
      effect: {
        type: 'permanent',
        afkGooseChance: 0.05, // 5% chance to auto-collect goose feathers while AFK
        afkFeatherRate: 1, // 1 feather per auto-collect
        description: '5% chance per hour to find a goose feather while AFK'
      },
      lore: "The geese no longer see you as a threat. They see you as one of them.",
      oneTime: true
    },

    // Tier 3: Premium joke items (200-500 feathers)
    goose_whistle: {
      id: 'goose_whistle',
      name: 'Ancient Goose Whistle',
      emoji: 'üéµ',
      description: 'A whistle that plays the sacred song of the geese. HJ√ñNK.',
      cost: 200,
      category: 'equipment',
      effect: {
        type: 'permanent',
        gooseSpawnRate: 1.25, // +25% goose spawn rate
        gooseAllyBonus: 1.1, // +10% goose ally effects
        description: '+25% goose spawn rate, +10% goose ally effects'
      },
      lore: "The ancient melody of HJ√ñNK echoes through the realm.",
      oneTime: true
    },

    cobra_chicken_egg: {
      id: 'cobra_chicken_egg',
      name: 'Cobra Chicken Egg',
      emoji: 'üê£',
      description: 'An egg pulsing with chaotic energy. It may hatch something terrible.',
      cost: 300,
      category: 'companion',
      effect: {
        type: 'permanent',
        unlocks: 'mini_cobra_chicken',
        companionBonus: {
          allBoopPower: 1.1, // +10% boop power
          chaosEventChance: 0.05, // +5% random event chance
          description: 'Mini Cobra Chicken companion: +10% boop power, +5% random events'
        }
      },
      lore: "Oh no. What have you done.",
      unlockCondition: { cobraChickenDefeated: true },
      oneTime: true
    },

    void_feather: {
      id: 'void_feather',
      name: 'Void Feather',
      emoji: 'üñ§',
      description: 'A feather that absorbs all light. It whispers secrets.',
      cost: 500,
      category: 'ultimate',
      effect: {
        type: 'permanent',
        voidGooseUnlock: true, // Unlocks Void Goose enemy type
        voidFeatherBonus: {
          allCurrencyGain: 1.05, // +5% all currency gains
          gooseRewards: 1.25, // +25% goose rewards
          rareCatChance: 1.1 // +10% rare cat chance
        },
        description: '+5% all currencies, +25% goose rewards, +10% rare cat chance'
      },
      lore: "From beyond the veil of reality, where geese are gods.",
      oneTime: true
    },

    // Tier 4: Ultimate items (1000+ feathers)
    honk_transcendence: {
      id: 'honk_transcendence',
      name: 'Scroll of HONK Transcendence',
      emoji: 'üìñ',
      description: 'The ultimate goose technique. HONK so powerful it defies reality.',
      cost: 1000,
      category: 'ultimate',
      effect: {
        type: 'permanent',
        unlocks: 'honk_technique',
        techniqueBonus: {
          name: 'TRANSCENDENT HONK',
          description: 'Active ability: Once per day, HONK to double all gains for 10 minutes',
          duration: 600000, // 10 minutes
          multiplier: 2.0,
          cooldown: 86400000 // 24 hours
        }
      },
      lore: "HJ√ñNK HJ√ñNK AM GOOSE. AND SO ARE YOU.",
      oneTime: true
    }
  }
};

// ===================================
// ECONOMY SYSTEM CLASS
// ===================================

class EconomySystem {
  constructor() {
    // Initialize currency balances
    this.currencies = {};
    for (const [id, currency] of Object.entries(CURRENCIES)) {
      this.currencies[id] = currency.startingAmount || 0;
    }

    // Shop purchases tracking
    this.gooseShopPurchases = {};
    this.conversionCooldowns = {};

    // Active effects from shop items
    this.activeEffects = [];
    this.permanentEffects = {};

    // Stats tracking
    this.stats = {
      totalEarned: {},
      totalSpent: {},
      conversionsPerformed: 0,
      gooseShopPurchases: 0
    };

    // Initialize stats
    for (const id of Object.keys(CURRENCIES)) {
      this.stats.totalEarned[id] = 0;
      this.stats.totalSpent[id] = 0;
    }
  }

  // ===================================
  // CORE CURRENCY METHODS
  // ===================================

  /**
   * Get current balance of a currency
   */
  getBalance(currencyId) {
    return this.currencies[currencyId] || 0;
  }

  /**
   * Get all currency balances
   */
  getAllBalances() {
    return { ...this.currencies };
  }

  /**
   * Add currency (with validation and tracking)
   */
  addCurrency(currencyId, amount, source = 'unknown') {
    if (amount < 0) {
      console.warn(`EconomySystem: Cannot add negative amount to ${currencyId}`);
      return false;
    }

    const currency = CURRENCIES[currencyId];
    if (!currency) {
      console.warn(`EconomySystem: Unknown currency ${currencyId}`);
      return false;
    }

    // Check for cap (Qi has realm-based caps)
    if (currency.hasCap) {
      const currentRealm = window.cultivationSystem?.currentRealm || 'mortal';
      const cap = currency.getCapForRealm(currentRealm);
      const currentAmount = this.currencies[currencyId];
      const newAmount = Math.min(currentAmount + amount, cap);
      amount = newAmount - currentAmount;
    }

    this.currencies[currencyId] += amount;
    this.stats.totalEarned[currencyId] += amount;

    // Sync with gameState if available
    this.syncToGameState(currencyId);

    return { success: true, amount, newBalance: this.currencies[currencyId] };
  }

  /**
   * Spend currency (with validation)
   */
  spendCurrency(currencyId, amount, purpose = 'unknown') {
    if (amount < 0) {
      console.warn(`EconomySystem: Cannot spend negative amount`);
      return { success: false, reason: 'Invalid amount' };
    }

    const currency = CURRENCIES[currencyId];
    if (!currency) {
      return { success: false, reason: 'Unknown currency' };
    }

    if (this.currencies[currencyId] < amount && !currency.canGoNegative) {
      return {
        success: false,
        reason: `Not enough ${currency.name}`,
        have: this.currencies[currencyId],
        need: amount
      };
    }

    this.currencies[currencyId] -= amount;
    this.stats.totalSpent[currencyId] += amount;

    // Sync with gameState
    this.syncToGameState(currencyId);

    return { success: true, spent: amount, newBalance: this.currencies[currencyId] };
  }

  /**
   * Check if player can afford a cost
   */
  canAfford(costs) {
    // costs can be a single {currencyId: amount} or array of same
    if (!Array.isArray(costs)) {
      costs = [costs];
    }

    for (const cost of costs) {
      for (const [currencyId, amount] of Object.entries(cost)) {
        if (this.currencies[currencyId] < amount) {
          return {
            canAfford: false,
            missing: {
              currency: currencyId,
              have: this.currencies[currencyId],
              need: amount,
              shortfall: amount - this.currencies[currencyId]
            }
          };
        }
      }
    }

    return { canAfford: true };
  }

  /**
   * Spend multiple currencies at once
   */
  spendMultiple(costs, purpose = 'purchase') {
    const affordCheck = this.canAfford(costs);
    if (!affordCheck.canAfford) {
      return { success: false, ...affordCheck };
    }

    // Flatten costs
    if (!Array.isArray(costs)) {
      costs = [costs];
    }

    const spent = {};
    for (const cost of costs) {
      for (const [currencyId, amount] of Object.entries(cost)) {
        this.currencies[currencyId] -= amount;
        this.stats.totalSpent[currencyId] += amount;
        spent[currencyId] = (spent[currencyId] || 0) + amount;
        this.syncToGameState(currencyId);
      }
    }

    return { success: true, spent };
  }

  // ===================================
  // CURRENCY CONVERSION
  // ===================================

  /**
   * Check if a conversion is available
   */
  canConvert(conversionId) {
    const conversion = CURRENCY_CONVERSIONS[conversionId];
    if (!conversion) {
      return { canConvert: false, reason: 'Unknown conversion' };
    }

    // Check unlock condition
    if (conversion.unlockCondition) {
      const cond = conversion.unlockCondition;
      if (cond.cultivationRealm && window.cultivationSystem) {
        const realmOrder = ['mortal', 'qiCondensation', 'foundationEstablishment', 'coreFormation', 'nascentSoul'];
        const currentIdx = realmOrder.indexOf(window.cultivationSystem.currentRealm);
        const requiredIdx = realmOrder.indexOf(cond.cultivationRealm);
        if (currentIdx < requiredIdx) {
          return { canConvert: false, reason: `Requires ${cond.cultivationRealm} realm` };
        }
      }
      if (cond.cobraChickenDefeated && window.gooseSystem && !window.gooseSystem.cobraChickenDefeated) {
        return { canConvert: false, reason: 'Requires defeating Cobra Chicken' };
      }
      if (cond.pagodaFloor && window.pagodaSystem) {
        if (window.pagodaSystem.highestFloor < cond.pagodaFloor) {
          return { canConvert: false, reason: `Requires Pagoda floor ${cond.pagodaFloor}` };
        }
      }
    }

    // Check cooldown
    if (conversion.cooldown > 0) {
      const lastUsed = this.conversionCooldowns[conversionId] || 0;
      const elapsed = Date.now() - lastUsed;
      if (elapsed < conversion.cooldown) {
        const remaining = conversion.cooldown - elapsed;
        return {
          canConvert: false,
          reason: 'On cooldown',
          cooldownRemaining: remaining
        };
      }
    }

    // Check minimum amount
    if (this.currencies[conversion.from] < conversion.minAmount) {
      return {
        canConvert: false,
        reason: `Need at least ${conversion.minAmount} ${CURRENCIES[conversion.from].name}`
      };
    }

    return { canConvert: true, conversion };
  }

  /**
   * Perform a currency conversion
   */
  convert(conversionId, amount = null) {
    const check = this.canConvert(conversionId);
    if (!check.canConvert) {
      return { success: false, ...check };
    }

    const conversion = CURRENCY_CONVERSIONS[conversionId];

    // Default to converting minimum amount if not specified
    if (amount === null) {
      amount = conversion.minAmount;
    }

    // Validate amount
    if (amount < conversion.minAmount) {
      return { success: false, reason: `Minimum conversion: ${conversion.minAmount}` };
    }

    if (this.currencies[conversion.from] < amount) {
      return {
        success: false,
        reason: `Not enough ${CURRENCIES[conversion.from].name}`
      };
    }

    // Calculate output
    const output = Math.floor(amount / conversion.rate);
    const actualInput = output * conversion.rate; // Only use exact multiples

    // Perform conversion
    this.currencies[conversion.from] -= actualInput;
    this.currencies[conversion.to] += output;

    // Track stats
    this.stats.totalSpent[conversion.from] += actualInput;
    this.stats.totalEarned[conversion.to] += output;
    this.stats.conversionsPerformed++;

    // Set cooldown if applicable
    if (conversion.cooldown > 0) {
      this.conversionCooldowns[conversionId] = Date.now();
    }

    // Sync with gameState
    this.syncToGameState(conversion.from);
    this.syncToGameState(conversion.to);

    return {
      success: true,
      input: { currency: conversion.from, amount: actualInput },
      output: { currency: conversion.to, amount: output }
    };
  }

  /**
   * Get all available conversions
   */
  getAvailableConversions() {
    const available = [];
    for (const [id, conversion] of Object.entries(CURRENCY_CONVERSIONS)) {
      const check = this.canConvert(id);
      available.push({
        id,
        ...conversion,
        available: check.canConvert,
        reason: check.reason,
        cooldownRemaining: check.cooldownRemaining
      });
    }
    return available;
  }

  // ===================================
  // GOOSE FEATHER SHOP
  // ===================================

  /**
   * Get all shop items with purchase status
   */
  getGooseShopItems() {
    const items = [];
    for (const [id, item] of Object.entries(GOOSE_FEATHER_SHOP.items)) {
      const purchased = this.gooseShopPurchases[id] || 0;
      const canPurchase = !item.oneTime || purchased === 0;
      const canAfford = this.currencies.gooseFeathers >= item.cost;

      // Check unlock conditions
      let unlocked = true;
      if (item.unlockCondition) {
        if (item.unlockCondition.cobraChickenDefeated && window.gooseSystem) {
          unlocked = window.gooseSystem.cobraChickenDefeated;
        }
      }

      items.push({
        ...item,
        purchased,
        canPurchase: canPurchase && canAfford && unlocked,
        canAfford,
        unlocked,
        soldOut: item.oneTime && purchased > 0
      });
    }
    return items;
  }

  /**
   * Purchase item from Goose Feather Shop
   */
  purchaseGooseItem(itemId) {
    const item = GOOSE_FEATHER_SHOP.items[itemId];
    if (!item) {
      return { success: false, reason: 'Item not found' };
    }

    // Check if one-time purchase and already purchased
    if (item.oneTime && this.gooseShopPurchases[itemId]) {
      return { success: false, reason: 'Already purchased' };
    }

    // Check unlock conditions
    if (item.unlockCondition) {
      if (item.unlockCondition.cobraChickenDefeated && window.gooseSystem) {
        if (!window.gooseSystem.cobraChickenDefeated) {
          return { success: false, reason: 'Defeat Cobra Chicken first!' };
        }
      }
    }

    // Check cost
    if (this.currencies.gooseFeathers < item.cost) {
      return {
        success: false,
        reason: 'Not enough Goose Feathers',
        have: this.currencies.gooseFeathers,
        need: item.cost
      };
    }

    // Spend feathers
    this.currencies.gooseFeathers -= item.cost;
    this.stats.totalSpent.gooseFeathers += item.cost;
    this.syncToGameState('gooseFeathers');

    // Track purchase
    this.gooseShopPurchases[itemId] = (this.gooseShopPurchases[itemId] || 0) + 1;
    this.stats.gooseShopPurchases++;

    // Apply effect
    const result = this.applyGooseItemEffect(item);

    return {
      success: true,
      item,
      effect: result,
      newBalance: this.currencies.gooseFeathers
    };
  }

  /**
   * Apply the effect of a purchased goose shop item
   */
  applyGooseItemEffect(item) {
    const effect = item.effect;

    switch (effect.type) {
      case 'permanent':
        // Store permanent effect
        this.permanentEffects[item.id] = effect;
        return { applied: 'permanent', effect };

      case 'temporary':
        // Add to active effects with expiration
        this.activeEffects.push({
          id: item.id,
          ...effect,
          expiresAt: Date.now() + effect.duration
        });
        return { applied: 'temporary', duration: effect.duration };

      case 'active':
        // Consumable with uses - store in consumables
        if (!this.consumables) this.consumables = {};
        this.consumables[item.id] = (this.consumables[item.id] || 0) + effect.uses;
        return { applied: 'consumable', uses: effect.uses };

      default:
        return { applied: 'unknown' };
    }
  }

  /**
   * Use a consumable from the goose shop
   */
  useGooseConsumable(itemId) {
    if (!this.consumables || !this.consumables[itemId]) {
      return { success: false, reason: 'No uses remaining' };
    }

    const item = GOOSE_FEATHER_SHOP.items[itemId];
    if (!item) {
      return { success: false, reason: 'Item not found' };
    }

    this.consumables[itemId]--;
    if (this.consumables[itemId] <= 0) {
      delete this.consumables[itemId];
    }

    // Execute the action
    const effect = item.effect;
    let result = {};

    switch (effect.action) {
      case 'force_goose_spawn':
        if (window.gooseSystem && !window.gooseSystem.activeGoose) {
          window.gooseSystem.spawnGoose();
          result = { action: 'goose_spawned' };
        } else {
          // Refund the use
          this.consumables[itemId] = (this.consumables[itemId] || 0) + 1;
          return { success: false, reason: 'Goose already active!' };
        }
        break;

      case 'random_reward':
        // Roll for reward
        const roll = Math.random();
        let cumulative = 0;
        for (const possibility of effect.possibilities) {
          cumulative += possibility.chance;
          if (roll < cumulative) {
            result = this.grantReward(possibility.reward);
            result.description = possibility.desc;
            break;
          }
        }
        break;
    }

    return { success: true, result };
  }

  /**
   * Grant a reward from random effects
   */
  grantReward(reward) {
    const results = {};

    if (reward.bp) {
      this.addCurrency('bp', reward.bp, 'goose_shop_reward');
      results.bp = reward.bp;
    }
    if (reward.jadeCatnip) {
      this.addCurrency('jadeCatnip', reward.jadeCatnip, 'goose_shop_reward');
      results.jadeCatnip = reward.jadeCatnip;
    }
    if (reward.gooseFeathers) {
      this.addCurrency('gooseFeathers', reward.gooseFeathers, 'goose_shop_reward');
      results.gooseFeathers = reward.gooseFeathers;
    }
    if (reward.cat && window.catSystem) {
      if (reward.cat === 'random_rare') {
        window.catSystem.recruitCat(0, { minRealm: 'sky' });
        results.cat = 'random_rare';
      } else if (reward.cat === 'goose_cat') {
        // Special goose cat - would need to be defined in cats.js
        window.catSystem.recruitCat(0, { specificCat: 'goose_cat' });
        results.cat = 'goose_cat';
      }
    }

    return results;
  }

  /**
   * Get combined effects from all permanent goose items
   */
  getGoosePermanentEffects() {
    const combined = {
      gooseDodgeReduction: 0,
      gooseTimerBonus: 0,
      goldenGooseChance: 0,
      gooseSpawnRate: 1,
      gooseAllyBonus: 1,
      afkGooseChance: 0,
      allCurrencyGain: 1,
      gooseRewards: 1,
      rareCatChance: 1,
      allBoopPower: 1,
      chaosEventChance: 0
    };

    for (const effect of Object.values(this.permanentEffects)) {
      if (effect.gooseDodgeReduction) combined.gooseDodgeReduction += effect.gooseDodgeReduction;
      if (effect.gooseTimerBonus) combined.gooseTimerBonus += effect.gooseTimerBonus;
      if (effect.goldenGooseChance) combined.goldenGooseChance += effect.goldenGooseChance;
      if (effect.gooseSpawnRate) combined.gooseSpawnRate *= effect.gooseSpawnRate;
      if (effect.gooseAllyBonus) combined.gooseAllyBonus *= effect.gooseAllyBonus;
      if (effect.afkGooseChance) combined.afkGooseChance += effect.afkGooseChance;
      if (effect.afkFeatherRate) combined.afkFeatherRate = (combined.afkFeatherRate || 0) + effect.afkFeatherRate;

      // Nested bonuses
      if (effect.voidFeatherBonus) {
        combined.allCurrencyGain *= effect.voidFeatherBonus.allCurrencyGain || 1;
        combined.gooseRewards *= effect.voidFeatherBonus.gooseRewards || 1;
        combined.rareCatChance *= effect.voidFeatherBonus.rareCatChance || 1;
      }
      if (effect.companionBonus) {
        combined.allBoopPower *= effect.companionBonus.allBoopPower || 1;
        combined.chaosEventChance += effect.companionBonus.chaosEventChance || 0;
      }
    }

    return combined;
  }

  /**
   * Update active temporary effects
   */
  updateActiveEffects() {
    const now = Date.now();
    this.activeEffects = this.activeEffects.filter(effect => effect.expiresAt > now);
  }

  /**
   * Get combined temporary effects
   */
  getActiveTemporaryEffects() {
    this.updateActiveEffects();

    const combined = {
      gooseRewardBonus: 1
    };

    for (const effect of this.activeEffects) {
      if (effect.gooseRewardBonus) combined.gooseRewardBonus *= effect.gooseRewardBonus;
    }

    return combined;
  }

  // ===================================
  // GAME STATE SYNC
  // ===================================

  /**
   * Sync a currency to the global gameState
   */
  syncToGameState(currencyId) {
    if (!window.gameState) return;

    // Map economy currency IDs to gameState property names
    const mapping = {
      bp: 'boopPoints',
      pp: 'purrPower',
      qi: 'qi',
      jadeCatnip: 'jadeCatnip',
      spiritStones: 'spiritStones',
      heavenlySeals: 'heavenlySeals',
      sectReputation: 'sectReputation',
      waifuTokens: 'waifuTokens',
      gooseFeathers: 'gooseFeathers'
    };

    const gameStateProp = mapping[currencyId];
    if (gameStateProp) {
      window.gameState[gameStateProp] = this.currencies[currencyId];
    }
  }

  /**
   * Sync all currencies to gameState
   */
  syncAllToGameState() {
    for (const id of Object.keys(CURRENCIES)) {
      this.syncToGameState(id);
    }
  }

  /**
   * Load currencies from gameState (on init)
   */
  loadFromGameState() {
    if (!window.gameState) return;

    const mapping = {
      boopPoints: 'bp',
      purrPower: 'pp',
      qi: 'qi',
      jadeCatnip: 'jadeCatnip',
      spiritStones: 'spiritStones',
      heavenlySeals: 'heavenlySeals',
      sectReputation: 'sectReputation',
      waifuTokens: 'waifuTokens',
      gooseFeathers: 'gooseFeathers'
    };

    for (const [gameStateProp, currencyId] of Object.entries(mapping)) {
      if (window.gameState[gameStateProp] !== undefined) {
        this.currencies[currencyId] = window.gameState[gameStateProp];
      }
    }
  }

  // ===================================
  // SERIALIZATION
  // ===================================

  /**
   * Serialize for save system
   */
  serialize() {
    return {
      currencies: { ...this.currencies },
      gooseShopPurchases: { ...this.gooseShopPurchases },
      conversionCooldowns: { ...this.conversionCooldowns },
      permanentEffects: { ...this.permanentEffects },
      activeEffects: this.activeEffects.map(e => ({ ...e })),
      consumables: this.consumables ? { ...this.consumables } : {},
      stats: {
        totalEarned: { ...this.stats.totalEarned },
        totalSpent: { ...this.stats.totalSpent },
        conversionsPerformed: this.stats.conversionsPerformed,
        gooseShopPurchases: this.stats.gooseShopPurchases
      }
    };
  }

  /**
   * Deserialize from save data
   */
  deserialize(data) {
    if (!data) return;

    if (data.currencies) {
      for (const [id, amount] of Object.entries(data.currencies)) {
        if (CURRENCIES[id]) {
          this.currencies[id] = amount;
        }
      }
    }

    this.gooseShopPurchases = data.gooseShopPurchases || {};
    this.conversionCooldowns = data.conversionCooldowns || {};
    this.permanentEffects = data.permanentEffects || {};
    this.activeEffects = data.activeEffects || [];
    this.consumables = data.consumables || {};

    if (data.stats) {
      this.stats.totalEarned = data.stats.totalEarned || {};
      this.stats.totalSpent = data.stats.totalSpent || {};
      this.stats.conversionsPerformed = data.stats.conversionsPerformed || 0;
      this.stats.gooseShopPurchases = data.stats.gooseShopPurchases || 0;
    }

    // Sync to gameState
    this.syncAllToGameState();
  }

  // ===================================
  // UTILITY METHODS
  // ===================================

  /**
   * Format currency amount for display
   */
  formatAmount(currencyId, amount = null) {
    if (amount === null) {
      amount = this.currencies[currencyId];
    }

    if (amount < 1000) return Math.floor(amount).toString();

    const suffixes = ['', 'K', 'M', 'B', 'T', 'Qi', 'Dao', 'Xian'];
    const tier = Math.min(Math.floor(Math.log10(amount) / 3), suffixes.length - 1);
    return (amount / Math.pow(10, tier * 3)).toFixed(1) + suffixes[tier];
  }

  /**
   * Get currency info for UI
   */
  getCurrencyInfo(currencyId) {
    const currency = CURRENCIES[currencyId];
    if (!currency) return null;

    return {
      ...currency,
      balance: this.currencies[currencyId],
      formattedBalance: this.formatAmount(currencyId)
    };
  }

  /**
   * Get all currencies for UI display
   */
  getAllCurrencyInfo() {
    return Object.keys(CURRENCIES)
      .map(id => this.getCurrencyInfo(id))
      .sort((a, b) => a.displayPriority - b.displayPriority);
  }
}

// ===================================
// EXPORTS
// ===================================

window.CURRENCIES = CURRENCIES;
window.CURRENCY_CONVERSIONS = CURRENCY_CONVERSIONS;
window.GOOSE_FEATHER_SHOP = GOOSE_FEATHER_SHOP;
window.EconomySystem = EconomySystem;

console.log('Economy System loaded successfully!');
